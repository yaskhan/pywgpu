"""
Definitions for index bounds checking.

This module provides policies and utilities for handling bounds checks
on array, vector, matrix, and texture accesses.
"""

from __future__ import annotations

from typing import TYPE_CHECKING
from enum import Enum
from dataclasses import dataclass

if TYPE_CHECKING:
    from ..arena import Handle, UniqueArena
    from ..ir import Expression, Type
    from ..valid import FunctionInfo


class BoundsCheckPolicy(Enum):
    """
    How should code generated by Naga do bounds checks?
    
    When a vector, matrix, or array index is out of bounds—either negative, or
    greater than or equal to the number of elements in the type—WGSL requires
    that some other index of the implementation's choice that is in bounds is
    used instead. (There are no types with zero elements.)
    
    Similarly, when out-of-bounds coordinates, array indices, or sample indices
    are presented to the WGSL textureLoad and textureStore operations, the
    operation is redirected to do something safe.
    
    Different users of Naga will prefer different defaults:
    
    - When used as part of a WebGPU implementation, the WGSL specification
      requires the Restrict behavior for array, vector, and matrix accesses,
      and either the Restrict or ReadZeroSkipWrite behaviors for texture
      accesses.
    
    - When used by the wgpu crate for native development, wgpu selects
      ReadZeroSkipWrite as its default.
    
    - Naga's own default is Unchecked, so that shader translations
      are as faithful to the original as possible.
    
    Attributes:
        RESTRICT: Replace out-of-bounds indexes with some arbitrary in-bounds index.
        READ_ZERO_SKIP_WRITE: Out-of-bounds reads return zero, and writes have no effect.
        UNCHECKED: Naga adds no checks to indexing operations.
    """
    RESTRICT = "restrict"
    READ_ZERO_SKIP_WRITE = "read_zero_skip_write"
    UNCHECKED = "unchecked"


@dataclass
class BoundsCheckPolicies:
    """
    Policies for injecting bounds checks during code generation.
    
    Attributes:
        index: How should the generated code handle array, vector, or matrix indices
            that are out of range?
        buffer: How should the generated code handle array, vector, or matrix indices
            that are out of range, when those values live in a GlobalVariable in
            the Storage or Uniform address spaces?
        image_load: How should the generated code handle image texel loads that are out
            of range?
        binding_array: How should the generated code handle binding array indexes that
            are out of bounds.
    """
    index: BoundsCheckPolicy = BoundsCheckPolicy.UNCHECKED
    buffer: BoundsCheckPolicy = BoundsCheckPolicy.UNCHECKED
    image_load: BoundsCheckPolicy = BoundsCheckPolicy.UNCHECKED
    binding_array: BoundsCheckPolicy = BoundsCheckPolicy.UNCHECKED
    
    def choose_policy(
        self,
        base: Handle[Expression],
        types: UniqueArena[Type],
        info: FunctionInfo,
    ) -> BoundsCheckPolicy:
        """
        Determine which policy applies to base.
        
        base is the "base" expression (the expression being indexed) of an Access
        and AccessIndex expression. This is either a pointer, a value, being directly
        indexed, or a binding array.
        
        Args:
            base: Handle to the base expression
            types: Arena of types
            info: Function info for analysis
            
        Returns:
            The applicable bounds check policy
        """
        # Placeholder - would need to analyze the base expression
        # to determine if it's a buffer access or other type
        return self.index


class IndexableLength:
    """
    Length of an indexable type (array, vector, matrix).
    
    This represents either a known constant length or a dynamic length
    that must be computed at runtime.
    """
    
    def __init__(self, length: int | None = None) -> None:
        """
        Initialize an IndexableLength.
        
        Args:
            length: The constant length, or None for dynamic length
        """
        self.length = length
    
    def is_known(self) -> bool:
        """Check if the length is known at compile time."""
        return self.length is not None
    
    def get(self) -> int:
        """
        Get the known length.
        
        Returns:
            The length
            
        Raises:
            RuntimeError: If length is not known
        """
        if self.length is None:
            raise RuntimeError("Length is not known")
        return self.length


class IndexableLengthError(Exception):
    """Error computing indexable length."""
    pass


__all__ = [
    "BoundsCheckPolicy",
    "BoundsCheckPolicies",
    "IndexableLength",
    "IndexableLengthError",
]

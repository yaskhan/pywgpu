"""
Generated component-wise operations.

This file is AUTO-GENERATED by generate_component_wise.py
DO NOT EDIT MANUALLY!
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import TYPE_CHECKING, Callable

from naga import (
    Expression, ExpressionType, Handle, Literal, Span,
    ScalarKind, TypeInner, TypeInnerType,
)

if TYPE_CHECKING:
    from naga.proc.constant_evaluator import ConstantEvaluator


# ============================================================================
# Extracted value types
# ============================================================================

class Scalar:
    """Extracted scalar values for component-wise operations."""

    @dataclass
    class AbstractFloat:
        """Maps to Literal.AbstractFloat."""
        values: list[float]

    @dataclass
    class F32:
        """Maps to Literal.F32."""
        values: list[float]

    @dataclass
    class F16:
        """Maps to Literal.F16."""
        values: list[float]

    @dataclass
    class AbstractInt:
        """Maps to Literal.AbstractInt."""
        values: list[int]

    @dataclass
    class U32:
        """Maps to Literal.U32."""
        values: list[int]

    @dataclass
    class I32:
        """Maps to Literal.I32."""
        values: list[int]

    @dataclass
    class U64:
        """Maps to Literal.U64."""
        values: list[int]

    @dataclass
    class I64:
        """Maps to Literal.I64."""
        values: list[int]


class Float:
    """Extracted float values for component-wise operations."""

    @dataclass
    class Abstract:
        """Maps to Literal.AbstractFloat."""
        values: list[float]

    @dataclass
    class F32:
        """Maps to Literal.F32."""
        values: list[float]

    @dataclass
    class F16:
        """Maps to Literal.F16."""
        values: list[float]


class ConcreteInt:
    """Extracted concreteint values for component-wise operations."""

    @dataclass
    class U32:
        """Maps to Literal.U32."""
        values: list[int]

    @dataclass
    class I32:
        """Maps to Literal.I32."""
        values: list[int]


class Signed:
    """Extracted signed values for component-wise operations."""

    @dataclass
    class AbstractFloat:
        """Maps to Literal.AbstractFloat."""
        values: list[float]

    @dataclass
    class AbstractInt:
        """Maps to Literal.AbstractInt."""
        values: list[int]

    @dataclass
    class F32:
        """Maps to Literal.F32."""
        values: list[float]

    @dataclass
    class F16:
        """Maps to Literal.F16."""
        values: list[float]

    @dataclass
    class I32:
        """Maps to Literal.I32."""
        values: list[int]



# ============================================================================
# Component-wise functions
# ============================================================================

def component_wise_scalar(
    eval: 'ConstantEvaluator',
    span: Span,
    exprs: list[Handle[Expression]],
    handler: Callable[[Scalar], Scalar],
) -> Handle[Expression]:
    """Perform component-wise scalar operation on expressions.

    If expressions are vectors of the same length, handler is called
    for each corresponding component of each vector.

    Args:
        eval: Constant evaluator instance
        span: Span for error reporting
        exprs: List of expressions to process
        handler: Function to call on component values

    Returns:
        Handle to the resulting expression
    """
    from naga.proc.constant_evaluator import ConstantEvaluatorError
    from naga import VectorSize

    if not exprs:
        raise ConstantEvaluatorError("No expressions provided")

    # Helper to evaluate zero values and splats
    def sanitize(expr: Handle[Expression]) -> Expression:
        return eval.expressions[eval.eval_zero_value_and_splat(expr, span)]

    # Process first expression to determine type
    first_expr = sanitize(exprs[0])

    # Match on expression type
    match first_expr:
        case Expression(type=ExpressionType.LITERAL, literal=Literal.AbstractFloat(value=x)):
            # Collect all values as AbstractFloat
            values = [x]
            for expr_handle in exprs[1:]:
                expr = sanitize(expr_handle)
                match expr:
                    case Expression(type=ExpressionType.LITERAL, literal=Literal.AbstractFloat(value=v)):
                        values.append(v)
                    case _:
                        raise ConstantEvaluatorError("Invalid math argument")

            # Call handler
            input_data = Scalar.AbstractFloat(values)
            result = handler(input_data)

            # Convert result back to expression
            if len(result.values) == 1:
                new_expr = Expression(
                    type=ExpressionType.LITERAL,
                    literal=Literal.AbstractFloat(result.values[0]),
                )
            else:
                raise ConstantEvaluatorError("Unexpected result length")

            return eval.register_evaluated_expr(new_expr, span)

        case Expression(type=ExpressionType.LITERAL, literal=Literal.F32(value=x)):
            # Collect all values as F32
            values = [x]
            for expr_handle in exprs[1:]:
                expr = sanitize(expr_handle)
                match expr:
                    case Expression(type=ExpressionType.LITERAL, literal=Literal.F32(value=v)):
                        values.append(v)
                    case _:
                        raise ConstantEvaluatorError("Invalid math argument")

            # Call handler
            input_data = Scalar.F32(values)
            result = handler(input_data)

            # Convert result back to expression
            if len(result.values) == 1:
                new_expr = Expression(
                    type=ExpressionType.LITERAL,
                    literal=Literal.F32(result.values[0]),
                )
            else:
                raise ConstantEvaluatorError("Unexpected result length")

            return eval.register_evaluated_expr(new_expr, span)

        case Expression(type=ExpressionType.LITERAL, literal=Literal.F16(value=x)):
            # Collect all values as F16
            values = [x]
            for expr_handle in exprs[1:]:
                expr = sanitize(expr_handle)
                match expr:
                    case Expression(type=ExpressionType.LITERAL, literal=Literal.F16(value=v)):
                        values.append(v)
                    case _:
                        raise ConstantEvaluatorError("Invalid math argument")

            # Call handler
            input_data = Scalar.F16(values)
            result = handler(input_data)

            # Convert result back to expression
            if len(result.values) == 1:
                new_expr = Expression(
                    type=ExpressionType.LITERAL,
                    literal=Literal.F16(result.values[0]),
                )
            else:
                raise ConstantEvaluatorError("Unexpected result length")

            return eval.register_evaluated_expr(new_expr, span)

        case Expression(type=ExpressionType.LITERAL, literal=Literal.AbstractInt(value=x)):
            # Collect all values as AbstractInt
            values = [x]
            for expr_handle in exprs[1:]:
                expr = sanitize(expr_handle)
                match expr:
                    case Expression(type=ExpressionType.LITERAL, literal=Literal.AbstractInt(value=v)):
                        values.append(v)
                    case _:
                        raise ConstantEvaluatorError("Invalid math argument")

            # Call handler
            input_data = Scalar.AbstractInt(values)
            result = handler(input_data)

            # Convert result back to expression
            if len(result.values) == 1:
                new_expr = Expression(
                    type=ExpressionType.LITERAL,
                    literal=Literal.AbstractInt(result.values[0]),
                )
            else:
                raise ConstantEvaluatorError("Unexpected result length")

            return eval.register_evaluated_expr(new_expr, span)

        case Expression(type=ExpressionType.LITERAL, literal=Literal.U32(value=x)):
            # Collect all values as U32
            values = [x]
            for expr_handle in exprs[1:]:
                expr = sanitize(expr_handle)
                match expr:
                    case Expression(type=ExpressionType.LITERAL, literal=Literal.U32(value=v)):
                        values.append(v)
                    case _:
                        raise ConstantEvaluatorError("Invalid math argument")

            # Call handler
            input_data = Scalar.U32(values)
            result = handler(input_data)

            # Convert result back to expression
            if len(result.values) == 1:
                new_expr = Expression(
                    type=ExpressionType.LITERAL,
                    literal=Literal.U32(result.values[0]),
                )
            else:
                raise ConstantEvaluatorError("Unexpected result length")

            return eval.register_evaluated_expr(new_expr, span)

        case Expression(type=ExpressionType.LITERAL, literal=Literal.I32(value=x)):
            # Collect all values as I32
            values = [x]
            for expr_handle in exprs[1:]:
                expr = sanitize(expr_handle)
                match expr:
                    case Expression(type=ExpressionType.LITERAL, literal=Literal.I32(value=v)):
                        values.append(v)
                    case _:
                        raise ConstantEvaluatorError("Invalid math argument")

            # Call handler
            input_data = Scalar.I32(values)
            result = handler(input_data)

            # Convert result back to expression
            if len(result.values) == 1:
                new_expr = Expression(
                    type=ExpressionType.LITERAL,
                    literal=Literal.I32(result.values[0]),
                )
            else:
                raise ConstantEvaluatorError("Unexpected result length")

            return eval.register_evaluated_expr(new_expr, span)

        case Expression(type=ExpressionType.LITERAL, literal=Literal.U64(value=x)):
            # Collect all values as U64
            values = [x]
            for expr_handle in exprs[1:]:
                expr = sanitize(expr_handle)
                match expr:
                    case Expression(type=ExpressionType.LITERAL, literal=Literal.U64(value=v)):
                        values.append(v)
                    case _:
                        raise ConstantEvaluatorError("Invalid math argument")

            # Call handler
            input_data = Scalar.U64(values)
            result = handler(input_data)

            # Convert result back to expression
            if len(result.values) == 1:
                new_expr = Expression(
                    type=ExpressionType.LITERAL,
                    literal=Literal.U64(result.values[0]),
                )
            else:
                raise ConstantEvaluatorError("Unexpected result length")

            return eval.register_evaluated_expr(new_expr, span)

        case Expression(type=ExpressionType.LITERAL, literal=Literal.I64(value=x)):
            # Collect all values as I64
            values = [x]
            for expr_handle in exprs[1:]:
                expr = sanitize(expr_handle)
                match expr:
                    case Expression(type=ExpressionType.LITERAL, literal=Literal.I64(value=v)):
                        values.append(v)
                    case _:
                        raise ConstantEvaluatorError("Invalid math argument")

            # Call handler
            input_data = Scalar.I64(values)
            result = handler(input_data)

            # Convert result back to expression
            if len(result.values) == 1:
                new_expr = Expression(
                    type=ExpressionType.LITERAL,
                    literal=Literal.I64(result.values[0]),
                )
            else:
                raise ConstantEvaluatorError("Unexpected result length")

            return eval.register_evaluated_expr(new_expr, span)

        case Expression(type=ExpressionType.COMPOSE, compose_ty=ty, compose_components=components):
            # Handle vector composition
            type_inner = eval.types[ty].inner
            match type_inner:
                case TypeInner(type=TypeInnerType.VECTOR, vector_size=size, vector_scalar=scalar):
                    # Check if scalar kind matches
                    if scalar.kind not in [ScalarKind.FLOAT, ScalarKind.ABSTRACTFLOAT, ScalarKind.SINT, ScalarKind.UINT, ScalarKind.ABSTRACTINT]:
                        raise ConstantEvaluatorError("Invalid math argument")

                    # Flatten first vector
                    from naga.proc.type_methods import flatten_compose
                    first_components = list(flatten_compose(ty, components, eval.expressions, eval.types))

                    # Collect component groups from all expressions
                    component_groups = [first_components]
                    for expr_handle in exprs[1:]:
                        expr = sanitize(expr_handle)
                        match expr:
                            case Expression(type=ExpressionType.COMPOSE, compose_ty=expr_ty, compose_components=expr_comps):
                                if eval.types[expr_ty].inner != eval.types[ty].inner:
                                    raise ConstantEvaluatorError("Vector type mismatch")
                                component_groups.append(list(flatten_compose(expr_ty, expr_comps, eval.expressions, eval.types)))
                            case _:
                                raise ConstantEvaluatorError("Invalid math argument")

                    # Process each component index
                    new_components = []
                    for idx in range(int(size)):
                        # Gather components at this index from all vectors
                        group = [comp_list[idx] for comp_list in component_groups]
                        # Recursively call this function for scalar components
                        result_handle = component_wise_scalar(eval, span, group, handler)
                        new_components.append(result_handle)

                    # Create new Compose expression
                    new_expr = Expression(
                        type=ExpressionType.COMPOSE,
                        compose_ty=ty,
                        compose_components=new_components,
                    )
                    return eval.register_evaluated_expr(new_expr, span)

                case _:
                    raise ConstantEvaluatorError("Invalid math argument")

        case _:
            raise ConstantEvaluatorError("Invalid math argument")


def component_wise_float(
    eval: 'ConstantEvaluator',
    span: Span,
    exprs: list[Handle[Expression]],
    handler: Callable[[Float], Float],
) -> Handle[Expression]:
    """Perform component-wise float operation on expressions.

    If expressions are vectors of the same length, handler is called
    for each corresponding component of each vector.

    Args:
        eval: Constant evaluator instance
        span: Span for error reporting
        exprs: List of expressions to process
        handler: Function to call on component values

    Returns:
        Handle to the resulting expression
    """
    from naga.proc.constant_evaluator import ConstantEvaluatorError
    from naga import VectorSize

    if not exprs:
        raise ConstantEvaluatorError("No expressions provided")

    # Helper to evaluate zero values and splats
    def sanitize(expr: Handle[Expression]) -> Expression:
        return eval.expressions[eval.eval_zero_value_and_splat(expr, span)]

    # Process first expression to determine type
    first_expr = sanitize(exprs[0])

    # Match on expression type
    match first_expr:
        case Expression(type=ExpressionType.LITERAL, literal=Literal.AbstractFloat(value=x)):
            # Collect all values as Abstract
            values = [x]
            for expr_handle in exprs[1:]:
                expr = sanitize(expr_handle)
                match expr:
                    case Expression(type=ExpressionType.LITERAL, literal=Literal.AbstractFloat(value=v)):
                        values.append(v)
                    case _:
                        raise ConstantEvaluatorError("Invalid math argument")

            # Call handler
            input_data = Float.Abstract(values)
            result = handler(input_data)

            # Convert result back to expression
            if len(result.values) == 1:
                new_expr = Expression(
                    type=ExpressionType.LITERAL,
                    literal=Literal.AbstractFloat(result.values[0]),
                )
            else:
                raise ConstantEvaluatorError("Unexpected result length")

            return eval.register_evaluated_expr(new_expr, span)

        case Expression(type=ExpressionType.LITERAL, literal=Literal.F32(value=x)):
            # Collect all values as F32
            values = [x]
            for expr_handle in exprs[1:]:
                expr = sanitize(expr_handle)
                match expr:
                    case Expression(type=ExpressionType.LITERAL, literal=Literal.F32(value=v)):
                        values.append(v)
                    case _:
                        raise ConstantEvaluatorError("Invalid math argument")

            # Call handler
            input_data = Float.F32(values)
            result = handler(input_data)

            # Convert result back to expression
            if len(result.values) == 1:
                new_expr = Expression(
                    type=ExpressionType.LITERAL,
                    literal=Literal.F32(result.values[0]),
                )
            else:
                raise ConstantEvaluatorError("Unexpected result length")

            return eval.register_evaluated_expr(new_expr, span)

        case Expression(type=ExpressionType.LITERAL, literal=Literal.F16(value=x)):
            # Collect all values as F16
            values = [x]
            for expr_handle in exprs[1:]:
                expr = sanitize(expr_handle)
                match expr:
                    case Expression(type=ExpressionType.LITERAL, literal=Literal.F16(value=v)):
                        values.append(v)
                    case _:
                        raise ConstantEvaluatorError("Invalid math argument")

            # Call handler
            input_data = Float.F16(values)
            result = handler(input_data)

            # Convert result back to expression
            if len(result.values) == 1:
                new_expr = Expression(
                    type=ExpressionType.LITERAL,
                    literal=Literal.F16(result.values[0]),
                )
            else:
                raise ConstantEvaluatorError("Unexpected result length")

            return eval.register_evaluated_expr(new_expr, span)

        case Expression(type=ExpressionType.COMPOSE, compose_ty=ty, compose_components=components):
            # Handle vector composition
            type_inner = eval.types[ty].inner
            match type_inner:
                case TypeInner(type=TypeInnerType.VECTOR, vector_size=size, vector_scalar=scalar):
                    # Check if scalar kind matches
                    if scalar.kind not in [ScalarKind.FLOAT, ScalarKind.ABSTRACTFLOAT]:
                        raise ConstantEvaluatorError("Invalid math argument")

                    # Flatten first vector
                    from naga.proc.type_methods import flatten_compose
                    first_components = list(flatten_compose(ty, components, eval.expressions, eval.types))

                    # Collect component groups from all expressions
                    component_groups = [first_components]
                    for expr_handle in exprs[1:]:
                        expr = sanitize(expr_handle)
                        match expr:
                            case Expression(type=ExpressionType.COMPOSE, compose_ty=expr_ty, compose_components=expr_comps):
                                if eval.types[expr_ty].inner != eval.types[ty].inner:
                                    raise ConstantEvaluatorError("Vector type mismatch")
                                component_groups.append(list(flatten_compose(expr_ty, expr_comps, eval.expressions, eval.types)))
                            case _:
                                raise ConstantEvaluatorError("Invalid math argument")

                    # Process each component index
                    new_components = []
                    for idx in range(int(size)):
                        # Gather components at this index from all vectors
                        group = [comp_list[idx] for comp_list in component_groups]
                        # Recursively call this function for scalar components
                        result_handle = component_wise_float(eval, span, group, handler)
                        new_components.append(result_handle)

                    # Create new Compose expression
                    new_expr = Expression(
                        type=ExpressionType.COMPOSE,
                        compose_ty=ty,
                        compose_components=new_components,
                    )
                    return eval.register_evaluated_expr(new_expr, span)

                case _:
                    raise ConstantEvaluatorError("Invalid math argument")

        case _:
            raise ConstantEvaluatorError("Invalid math argument")


def component_wise_concrete_int(
    eval: 'ConstantEvaluator',
    span: Span,
    exprs: list[Handle[Expression]],
    handler: Callable[[ConcreteInt], ConcreteInt],
) -> Handle[Expression]:
    """Perform component-wise concreteint operation on expressions.

    If expressions are vectors of the same length, handler is called
    for each corresponding component of each vector.

    Args:
        eval: Constant evaluator instance
        span: Span for error reporting
        exprs: List of expressions to process
        handler: Function to call on component values

    Returns:
        Handle to the resulting expression
    """
    from naga.proc.constant_evaluator import ConstantEvaluatorError
    from naga import VectorSize

    if not exprs:
        raise ConstantEvaluatorError("No expressions provided")

    # Helper to evaluate zero values and splats
    def sanitize(expr: Handle[Expression]) -> Expression:
        return eval.expressions[eval.eval_zero_value_and_splat(expr, span)]

    # Process first expression to determine type
    first_expr = sanitize(exprs[0])

    # Match on expression type
    match first_expr:
        case Expression(type=ExpressionType.LITERAL, literal=Literal.U32(value=x)):
            # Collect all values as U32
            values = [x]
            for expr_handle in exprs[1:]:
                expr = sanitize(expr_handle)
                match expr:
                    case Expression(type=ExpressionType.LITERAL, literal=Literal.U32(value=v)):
                        values.append(v)
                    case _:
                        raise ConstantEvaluatorError("Invalid math argument")

            # Call handler
            input_data = ConcreteInt.U32(values)
            result = handler(input_data)

            # Convert result back to expression
            if len(result.values) == 1:
                new_expr = Expression(
                    type=ExpressionType.LITERAL,
                    literal=Literal.U32(result.values[0]),
                )
            else:
                raise ConstantEvaluatorError("Unexpected result length")

            return eval.register_evaluated_expr(new_expr, span)

        case Expression(type=ExpressionType.LITERAL, literal=Literal.I32(value=x)):
            # Collect all values as I32
            values = [x]
            for expr_handle in exprs[1:]:
                expr = sanitize(expr_handle)
                match expr:
                    case Expression(type=ExpressionType.LITERAL, literal=Literal.I32(value=v)):
                        values.append(v)
                    case _:
                        raise ConstantEvaluatorError("Invalid math argument")

            # Call handler
            input_data = ConcreteInt.I32(values)
            result = handler(input_data)

            # Convert result back to expression
            if len(result.values) == 1:
                new_expr = Expression(
                    type=ExpressionType.LITERAL,
                    literal=Literal.I32(result.values[0]),
                )
            else:
                raise ConstantEvaluatorError("Unexpected result length")

            return eval.register_evaluated_expr(new_expr, span)

        case Expression(type=ExpressionType.COMPOSE, compose_ty=ty, compose_components=components):
            # Handle vector composition
            type_inner = eval.types[ty].inner
            match type_inner:
                case TypeInner(type=TypeInnerType.VECTOR, vector_size=size, vector_scalar=scalar):
                    # Check if scalar kind matches
                    if scalar.kind not in [ScalarKind.SINT, ScalarKind.UINT]:
                        raise ConstantEvaluatorError("Invalid math argument")

                    # Flatten first vector
                    from naga.proc.type_methods import flatten_compose
                    first_components = list(flatten_compose(ty, components, eval.expressions, eval.types))

                    # Collect component groups from all expressions
                    component_groups = [first_components]
                    for expr_handle in exprs[1:]:
                        expr = sanitize(expr_handle)
                        match expr:
                            case Expression(type=ExpressionType.COMPOSE, compose_ty=expr_ty, compose_components=expr_comps):
                                if eval.types[expr_ty].inner != eval.types[ty].inner:
                                    raise ConstantEvaluatorError("Vector type mismatch")
                                component_groups.append(list(flatten_compose(expr_ty, expr_comps, eval.expressions, eval.types)))
                            case _:
                                raise ConstantEvaluatorError("Invalid math argument")

                    # Process each component index
                    new_components = []
                    for idx in range(int(size)):
                        # Gather components at this index from all vectors
                        group = [comp_list[idx] for comp_list in component_groups]
                        # Recursively call this function for scalar components
                        result_handle = component_wise_concrete_int(eval, span, group, handler)
                        new_components.append(result_handle)

                    # Create new Compose expression
                    new_expr = Expression(
                        type=ExpressionType.COMPOSE,
                        compose_ty=ty,
                        compose_components=new_components,
                    )
                    return eval.register_evaluated_expr(new_expr, span)

                case _:
                    raise ConstantEvaluatorError("Invalid math argument")

        case _:
            raise ConstantEvaluatorError("Invalid math argument")


def component_wise_signed(
    eval: 'ConstantEvaluator',
    span: Span,
    exprs: list[Handle[Expression]],
    handler: Callable[[Signed], Signed],
) -> Handle[Expression]:
    """Perform component-wise signed operation on expressions.

    If expressions are vectors of the same length, handler is called
    for each corresponding component of each vector.

    Args:
        eval: Constant evaluator instance
        span: Span for error reporting
        exprs: List of expressions to process
        handler: Function to call on component values

    Returns:
        Handle to the resulting expression
    """
    from naga.proc.constant_evaluator import ConstantEvaluatorError
    from naga import VectorSize

    if not exprs:
        raise ConstantEvaluatorError("No expressions provided")

    # Helper to evaluate zero values and splats
    def sanitize(expr: Handle[Expression]) -> Expression:
        return eval.expressions[eval.eval_zero_value_and_splat(expr, span)]

    # Process first expression to determine type
    first_expr = sanitize(exprs[0])

    # Match on expression type
    match first_expr:
        case Expression(type=ExpressionType.LITERAL, literal=Literal.AbstractFloat(value=x)):
            # Collect all values as AbstractFloat
            values = [x]
            for expr_handle in exprs[1:]:
                expr = sanitize(expr_handle)
                match expr:
                    case Expression(type=ExpressionType.LITERAL, literal=Literal.AbstractFloat(value=v)):
                        values.append(v)
                    case _:
                        raise ConstantEvaluatorError("Invalid math argument")

            # Call handler
            input_data = Signed.AbstractFloat(values)
            result = handler(input_data)

            # Convert result back to expression
            if len(result.values) == 1:
                new_expr = Expression(
                    type=ExpressionType.LITERAL,
                    literal=Literal.AbstractFloat(result.values[0]),
                )
            else:
                raise ConstantEvaluatorError("Unexpected result length")

            return eval.register_evaluated_expr(new_expr, span)

        case Expression(type=ExpressionType.LITERAL, literal=Literal.AbstractInt(value=x)):
            # Collect all values as AbstractInt
            values = [x]
            for expr_handle in exprs[1:]:
                expr = sanitize(expr_handle)
                match expr:
                    case Expression(type=ExpressionType.LITERAL, literal=Literal.AbstractInt(value=v)):
                        values.append(v)
                    case _:
                        raise ConstantEvaluatorError("Invalid math argument")

            # Call handler
            input_data = Signed.AbstractInt(values)
            result = handler(input_data)

            # Convert result back to expression
            if len(result.values) == 1:
                new_expr = Expression(
                    type=ExpressionType.LITERAL,
                    literal=Literal.AbstractInt(result.values[0]),
                )
            else:
                raise ConstantEvaluatorError("Unexpected result length")

            return eval.register_evaluated_expr(new_expr, span)

        case Expression(type=ExpressionType.LITERAL, literal=Literal.F32(value=x)):
            # Collect all values as F32
            values = [x]
            for expr_handle in exprs[1:]:
                expr = sanitize(expr_handle)
                match expr:
                    case Expression(type=ExpressionType.LITERAL, literal=Literal.F32(value=v)):
                        values.append(v)
                    case _:
                        raise ConstantEvaluatorError("Invalid math argument")

            # Call handler
            input_data = Signed.F32(values)
            result = handler(input_data)

            # Convert result back to expression
            if len(result.values) == 1:
                new_expr = Expression(
                    type=ExpressionType.LITERAL,
                    literal=Literal.F32(result.values[0]),
                )
            else:
                raise ConstantEvaluatorError("Unexpected result length")

            return eval.register_evaluated_expr(new_expr, span)

        case Expression(type=ExpressionType.LITERAL, literal=Literal.F16(value=x)):
            # Collect all values as F16
            values = [x]
            for expr_handle in exprs[1:]:
                expr = sanitize(expr_handle)
                match expr:
                    case Expression(type=ExpressionType.LITERAL, literal=Literal.F16(value=v)):
                        values.append(v)
                    case _:
                        raise ConstantEvaluatorError("Invalid math argument")

            # Call handler
            input_data = Signed.F16(values)
            result = handler(input_data)

            # Convert result back to expression
            if len(result.values) == 1:
                new_expr = Expression(
                    type=ExpressionType.LITERAL,
                    literal=Literal.F16(result.values[0]),
                )
            else:
                raise ConstantEvaluatorError("Unexpected result length")

            return eval.register_evaluated_expr(new_expr, span)

        case Expression(type=ExpressionType.LITERAL, literal=Literal.I32(value=x)):
            # Collect all values as I32
            values = [x]
            for expr_handle in exprs[1:]:
                expr = sanitize(expr_handle)
                match expr:
                    case Expression(type=ExpressionType.LITERAL, literal=Literal.I32(value=v)):
                        values.append(v)
                    case _:
                        raise ConstantEvaluatorError("Invalid math argument")

            # Call handler
            input_data = Signed.I32(values)
            result = handler(input_data)

            # Convert result back to expression
            if len(result.values) == 1:
                new_expr = Expression(
                    type=ExpressionType.LITERAL,
                    literal=Literal.I32(result.values[0]),
                )
            else:
                raise ConstantEvaluatorError("Unexpected result length")

            return eval.register_evaluated_expr(new_expr, span)

        case Expression(type=ExpressionType.COMPOSE, compose_ty=ty, compose_components=components):
            # Handle vector composition
            type_inner = eval.types[ty].inner
            match type_inner:
                case TypeInner(type=TypeInnerType.VECTOR, vector_size=size, vector_scalar=scalar):
                    # Check if scalar kind matches
                    if scalar.kind not in [ScalarKind.SINT, ScalarKind.ABSTRACTINT, ScalarKind.FLOAT, ScalarKind.ABSTRACTFLOAT]:
                        raise ConstantEvaluatorError("Invalid math argument")

                    # Flatten first vector
                    from naga.proc.type_methods import flatten_compose
                    first_components = list(flatten_compose(ty, components, eval.expressions, eval.types))

                    # Collect component groups from all expressions
                    component_groups = [first_components]
                    for expr_handle in exprs[1:]:
                        expr = sanitize(expr_handle)
                        match expr:
                            case Expression(type=ExpressionType.COMPOSE, compose_ty=expr_ty, compose_components=expr_comps):
                                if eval.types[expr_ty].inner != eval.types[ty].inner:
                                    raise ConstantEvaluatorError("Vector type mismatch")
                                component_groups.append(list(flatten_compose(expr_ty, expr_comps, eval.expressions, eval.types)))
                            case _:
                                raise ConstantEvaluatorError("Invalid math argument")

                    # Process each component index
                    new_components = []
                    for idx in range(int(size)):
                        # Gather components at this index from all vectors
                        group = [comp_list[idx] for comp_list in component_groups]
                        # Recursively call this function for scalar components
                        result_handle = component_wise_signed(eval, span, group, handler)
                        new_components.append(result_handle)

                    # Create new Compose expression
                    new_expr = Expression(
                        type=ExpressionType.COMPOSE,
                        compose_ty=ty,
                        compose_components=new_components,
                    )
                    return eval.register_evaluated_expr(new_expr, span)

                case _:
                    raise ConstantEvaluatorError("Invalid math argument")

        case _:
            raise ConstantEvaluatorError("Invalid math argument")

